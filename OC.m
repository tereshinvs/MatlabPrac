%syms t %новая переменная

%A = [-7 5; -6 4];
%syms l
%det(A-l*eye(2))
%solve(ans) % нашли собственные значения

%B = A+eye(2)
%null(B)
%null(B)/ans(l)

%B = A+2*eye(2)

%inv([5 1; 6 1])
%inv(sym([5 1;6 1]))

%------
% вернемся к задаче

A = [-7 5; -6 4	];

syms t
expAt = [exp(t) 0; 0 exp(2*t)]
% subs - подстановка
H = subs(expAt*[1;2],t,log(sym(2))-t) % посчитали H

% simplify, simple - упрощает выражения
H = simple(H);
H
% simple делает множество всяких упрощений, выводит их названия. Выбираем
% то, что хочется, и делаем help на команду. #Пример: help collect

% H' - транспонировать и сопрячь, для комплексных. H.' - просто транспонировать, для
% вещественных. help transponse/ctransponse
syms l1 l2
l = [l1; l2]
h = simplify(H).'*l;
h

rho = int(h^2, t, sym(0), log(sym(2))) % интеграл, стоящий в выражении для ро. Получаем, подставляем туда (см тетрадь)
mu0 = subs(subs(rho, l1, sym(4)), l2, sym(1)) % получаем мю касания
% пишем везде sym(число), т.к. иначе он начнет считать численно, а нам это
% не надо. Надо попробовать и сравнить. sym делает число символом
% #Пример: log(sym(2)) и log(2)
invW = 49 * 3 / sym(229) * [3/2 14/3; 14/3 15] % получили это безобразие из ро (W?)

x = invW * [4; 1] / sqrt([4 1] * invW * [4; 1]) % [4;1] = l;
% легко проверить, что x лежит на прямой
[4 1] * x % =7

% т.о. мы получили задачу из точки в точку, но от этого понятней не становится. Заебись.
q = int(h^2,t,0,log(sym(2)))
% ф-ция Лагранжа
syms l % лямбда
syms L
L = q + l * (l1 + 3*l2 -1)
diff(L, l1)
f1 = ans
% help solve
% где-то тут была ошибка
f2 = diff(L, l2)
f1
f2
s = solve('l+3*l1 + (28*l2) = 0', '.....', 'l1', 'l2') %короче там 'f1 = 0', 'f2 = 0'
s.l1
s.l2
solve(s.l1 + 3*s.l2 - 1)
l = ans
simplify(s.l1);
s.l1
% l1* = 2, l2* - -1/3
subs(subs(q, 'l1', sym(2)), 'l2', sym(-1/3))
subs(h, 'l1', sym(2))
subs(subs(h, 'l1', sym(2)), 'l2', sym(-1/3))
u = ans* 9 / 13
int(u^2, 't',0,log(sym(2))) % совпало, все ок
